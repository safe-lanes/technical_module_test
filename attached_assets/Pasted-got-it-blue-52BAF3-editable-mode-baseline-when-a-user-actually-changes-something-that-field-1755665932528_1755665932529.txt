got it — blue `#52BAF3` = editable mode baseline; when a user actually changes something, that field’s label + value flip to red `#FF3B3O` to indicate “modified”. here’s the exact prompt to give Replit so it builds the behavior you want without inventing new UI.

---

# Prompt: “Modify PMS” – enable true edit mode + live diff highlight + pending requests

## Goal (do not deviate)

Use the **existing screens** (Components, Work Orders, Spares, Stores). When opened via **Modify PMS**, show the same forms in **Edit Mode** (baseline text in `#52BAF3`) and allow full editing. Any user change immediately highlights both the **label and the value** in **`#FF3B3O`**. On **Submit**, create a **Pending** change request visible on the **Modify PMS dashboard**. No changes are applied to live data until approved by office.

---

## Scope

Implement for:

* Components (Sections A–H)
* Work Orders (planned + unplanned forms)
* Spares (part rows, min/critical/location, etc.)
* Stores (items & UOM, min, locations)

Do **not** change the look, layout, section order, or control types. Only add “Modify mode” wiring, highlighting, and submit-to-pending behavior.

---

## Entry to Modify Mode

From **Modify PMS ➜ New Change Request**:

1. User picks target type: **Components / Work Orders / Spares / Stores**.
2. App navigates to the **actual target screen** but sets `mode="modify"` (e.g., query param `?modify=1` or route state).
3. In `mode="modify"`:

   * All fields become editable (exact controls you already use).
   * All labels + values render in **`#52BAF3`** to indicate editable baseline.
   * Show a fixed **Submit** button at the bottom/right (same visual style as app).
   * Keep **Add / Edit / Delete row** actions active wherever they exist (WO rows, spares rows, document rows, etc.).

---

## Live Diff Highlighting (critical)

Behavior:

* When a field (text, select, date, numeric) value differs from **original snapshot**, immediately:

  * Add class `.is-edited` to the field **and** its label.
  * Color both in **`#FF3B3O`**.
* When a user reverts the value back to original, remove `.is-edited`.
* For **row operations**:

  * **New row** → mark entire row with `.row-added` (left border `#FF3B3O`).
  * **Deleted row** → mark with `.row-deleted` until submit (strike-through value text + light red background). Do not remove immediately; let user undo before submit.

CSS to add (names exact):

```css
/* baseline editable */
.modify-mode [data-field-label],
.modify-mode [data-field-value] {
  color: #52BAF3;
}

/* changed */
.modify-mode .is-edited [data-field-label],
.modify-mode .is-edited [data-field-value],
.modify-mode [data-field-label].is-edited,
.modify-mode [data-field-value].is-edited {
  color: #FF3B3O;
}

/* rows */
.modify-mode .row-added { border-left: 3px solid #FF3B3O; }
.modify-mode .row-deleted { background: rgba(255,59,48,0.08); text-decoration: line-through; }
```

Implementation notes:

* Wrap each labeled input with a container:
  `<div class="field" data-field-key="A.Maker"><label data-field-label>Maker</label><input data-field-value .../></div>`
* On initial load, store a **deep clone** of the original form data as `originalData`.
* On input/change/blur, compare current value to `originalData[fieldKey]`. Toggle `.is-edited` on both label and value container accordingly.

---

## Data capture & submit

### Payload structure (all target types)

```json
{
  "targetType": "component|workorder|spare|store",
  "targetId": "<uuid or code>",
  "targetPath": "<for components: componentCode; for WO: woId; for spares/stores: itemId>",
  "modifyModeVersion": 1,
  "original": { ...full snapshot... },
  "proposed": { ...full current values... },
  "diff": {
    "fields": [
      { "key": "A.Maker", "from": "Old", "to": "New" },
      ...
    ],
    "rows": {
      "added": [ { "section": "C.WorkOrders", "row": { ... } } ],
      "deleted": [ { "section": "C.WorkOrders", "rowId": "..." } ],
      "changed": [ { "section": "C.WorkOrders", "rowId": "...", "fields": [ ... ] } ]
    }
  },
  "submittedBy": "<currentUserId>",
  "submittedAt": "<iso timestamp>",
  "status": "Pending"
}
```

### Submit button

* Validate normal form rules.
* If **no changes** detected (no `.is-edited`, no row-added/deleted/changed) → block submit with toast “No changes to submit.”
* On **success**, write a **ChangeRequest** record and redirect back to **Modify PMS dashboard** where the new request appears at the top with **Status: Pending**.

---

## Change requests storage (frontend mocks or API)

Create/expand an endpoint:

* `POST /api/change-requests` → create pending request
* `GET /api/change-requests?status=Pending` → list for dashboard
* Record shape:

```json
{
  "id": "<uuid>",
  "targetType": "...",
  "targetId": "...",
  "title": "Component 1.1.1 – Proposed edits",
  "status": "Pending",
  "submittedBy": "user@ship",
  "submittedAt": "2025-08-20T10:00:00Z",
  "diffSummaryCount": 7
}
```

(If APIs not ready, use in-memory store or local mock, but wire the UI exactly as above so we only swap the data layer later.)

---

## Add/Edit/Delete behavior by area

**Components**

* All A–H fields editable.
* Section C (Work Orders table inside component): allow **Add**, **Edit**, **Delete** WO rows in modify mode.
* Spares table inside component (E): allow **Add/Edit/Delete** rows.
* Drawings & Manuals: allow **Add** document rows and mark added as `.row-added`.
* Every edited field/row must reflect live highlighting rules.

**Work Orders**

* For **Planned WO** and **Unplanned WO** forms: fields editable, “Add Field” buttons still work.
* Any changed input/selection flips to `#FF3B3O`.

**Spares**

* Fields: Part Name, Min, Critical flag, Location, UOM, etc. fully editable.
* Row changes (bulk or single) follow add/changed/deleted highlighting.

**Stores**

* Items (with UOM, Min, Location) fully editable; same rules for highlighting and row changes.

---

## Navigation & persistence

* Keep a non-destructive flow: nothing writes to live entities in modify mode.
* All user edits exist only in the **proposed** payload until office **approves**.
* After Submit, show a toast: “Change request submitted (Pending). Review in Modify PMS.”

---

## QA Acceptance

1. Enter modify mode on each area; all fonts are **`#52BAF3`** initially.
2. Edit any field → label + value change to **`#FF3B3O`** instantly.
3. Add a row → left red border. Delete a row → strike-through + pale red bg.
4. Revert any field to its original value → it returns to **`#52BAF3`**.
5. Submit with edits → Pending request appears on Modify PMS dashboard.
6. Submit without edits → blocked with “No changes to submit.”
7. No layout/UI drift vs current screens.

---

## Dev notes / hooks

* Add a reusable `useModifyMode(originalData)` hook that:

  * Holds `originalData`, `currentData`
  * Exposes `isEdited(fieldKey)`, `markRowAdded`, `markRowDeleted`, `getDiff()`
  * Auto-applies `.is-edited` classes on change
* All input components should accept a `data-field-key` prop for diff mapping.
* Ensure performance by debouncing comparisons on fast typing.
* Keep keyboard accessibility intact; do not hide existing validation.

---

Deliver this exactly. If any section or field is unclear, **ask a concrete, single-sentence question** before implementing that part.
