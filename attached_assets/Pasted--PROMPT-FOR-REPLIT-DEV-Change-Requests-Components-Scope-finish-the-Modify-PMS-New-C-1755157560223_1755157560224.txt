**PROMPT FOR REPLIT / DEV — Change Requests (Components)**

> Scope: finish the **Modify PMS → New Change Request → Category: Components** flow so users can propose edits directly on the component form (Sections A–H) with clear red change-highlights and proper add/edit/remove for **Work Orders** and **Spares**.
> DO NOT modify any other module’s live create/edit flows, trees, or numbering. No live updates should occur from this screen—**only a change-request payload** is created.

---

## 0) Guard rails (must-follow)

* Do **not** change UI/UX of the normal Components page, Add/Edit Component modal, Work Orders module, Spares module, Running Hours, Stores, etc.
* Do **not** call any “live” save/update/delete APIs from the CR form. All user actions here are **intent only** that produce a CR diff payload and POST it to the CR API.
* Keep existing component tree and layout intact. Populate this CR form with the **exact same data** that the read-only component info page shows.
* Keep existing styles; only add the small red “changed” affordances specified below (scoped CSS classes).

---

## 1) Load the full editable form with current values

When user creates a CR for Components and selects a target component:

* Render the **same sections A–H** as in the read-only component info page, but **editable**.
* Pre-fill every field with the component’s current values. Use the same labels/ordering/controls.
* On mount, take and keep a **deep clone** of all pre-filled values as `originalData`.

If any field currently doesn’t show the value in this CR form, fix the binding so it does. (The read-only screen already has the data—reuse the same DTO.)

---

## 2) Change tracking (red highlighting)

* On any field change, compare against `originalData`. If different:

  * Add classes:

    * `.cr-changed` on the input/select/checkbox/date control.
    * `.cr-changed-row` on the row/container.
    * `.cr-changed-label` on the field label.
  * Increment a per-section change count and display a small chip in the section header, e.g.
    `A. Component Information  ▪  3 changes`
* If the user reverts a field back to its original value, remove the classes and decrement counts.
* Include **non-text** changes (checkboxes, select values, date, file name, added/removed rows, etc).
* Add these **scoped** styles (don’t overwrite the theme):

```css
.cr-changed{outline:2px solid #e06666!important}
.cr-changed-row{box-shadow:inset 3px 0 0 #e06666;background:#fff9f9}
.cr-changed-label{color:#d43c3c;font-weight:600}
.section-chip{margin-left:.5rem;font-size:.85rem;background:#ffe3e3;color:#b30000;border-radius:8px;padding:.1rem .4rem}
.strike-removed{text-decoration:line-through;opacity:.6}
```

---

## 3) Section C – Work Orders (edit / add / delete as CR intent)

**Render** existing WOs in the table (as now) with these actions per row:

* **Edit (pencil)**: turn the row into inline editable fields:

  * `Job Title`, `Assigned To`, `Frequency Type` (Calendar/Running Hours), `Frequency Value`, `Initial Next Due`, `Notes` (if present).
* **Delete (trash)**: mark the row `pendingDelete=true`, apply `.strike-removed` and `.cr-changed-row`. No live delete.
* **Add WO** button: insert a new inline row with the same fields, flagged `isNew=true`.

**Validation**

* Job Title required.
* Frequency Type required.
* Frequency Value > 0 when required.
* Initial Next Due valid date.

**CR diff model (front-end state → payload)**

* Any edited row → `changes.modified.workOrders[]` with `{ woNo|woId, fields: { <field>: {from,to}, ... } }`.
* Any new row → `changes.added.workOrders[]` with full row values (no `from`).
* Any deleted row → `changes.removed.workOrders[]` with `{ woNo|woId }`.

**Highlighting**

* When a row field changes, apply the red classes per §2.
* Entire deleted rows use `.strike-removed` + `.cr-changed-row`.

**Important**: Do not call Work Orders live APIs from this screen.

---

## 4) Section E – Spares (link / unlink / edit)

Existing grid columns: `Part Code, Part Name, Min, Critical, Location`.

* Inline edit for: **Min** (number), **Critical** (Yes/No), **Location** (existing control).
* **Add Spares** button opens a **link picker** (searchable by part code/name). Selection inserts rows flagged `isLinkedNew=true`.
* Trash on a spare row marks it `pendingUnlink=true` and applies `.strike-removed` + `.cr-changed-row`.

**CR diff model**

* Modified spare attrs → `changes.modified.spares[]` with `{ partCode|spareId, fields:{min:{from,to}, critical:{from,to}, location:{from,to}} }`.
* New link → `changes.added.spares[]` with `{ partCode|spareId, min?, critical?, location? }`.
* Unlinked spare → `changes.removed.spares[]` with `{ partCode|spareId }`.

Again, **no live** spare-link changes here.

---

## 5) Sections F–H (Documents, Classification, Requisitions)

* Allow Add/Rename/Remove of documents **as intent only**. (If a file is uploaded, store the temp file handle and include metadata in CR; actual move/write happens on approval process later.)
* Allow inline edits for G & H fields; track diffs and highlight as per §2.

---

## 6) Submit vs Cancel

* **Cancel**: discard state and return to CR list.
* **Submit**: validate all edited/new rows; if invalid, block submit and show inline errors.
* Build the **CR payload** (see schema below) and POST to the **existing change-request endpoint** (or create stable endpoint if missing), then return to CR list with a toast “Change request submitted”.

**CR payload schema (example)**

```json
{
  "type": "COMPONENT",
  "target": { "componentId": "…", "componentCode": "1.1.1", "vesselId": "…" },
  "title": "…",
  "reason": "…",
  "summary": { "A": 3, "C": {"added":1,"modified":2,"removed":1}, "E": {"added":1,"modified":1,"removed":0} },
  "diff": {
    "A.maker": {"from": "Generic Manufacturer", "to": "ACME Marine"},
    "A.department": {"from":"Engine","to":"Machinery"},
    "B.runningHours": {"from": 12580, "to": 20000},

    "C.workOrders.added": [
      {"tempId": "new-1", "jobTitle":"Weekly Checks", "frequencyType":"Calendar", "frequencyValue":7, "assignedTo":"2nd Engineer", "initialNextDue":"2025-06-02"}
    ],
    "C.workOrders.modified": [
      {"woNo":"WO-6.1.1-OHM6", "fields":{"frequencyType":{"from":"Calendar","to":"Running Hours"}, "frequencyValue":{"from":30,"to":500}}}
    ],
    "C.workOrders.removed": [
      {"woNo":"WO-2024-013"}
    ],

    "E.spares.added":[{"partCode":"SP-NEW-007","min":2,"critical":"No","location":"Store Room A"}],
    "E.spares.modified":[{"partCode":"SP-306-001","fields":{"min":{"from":1,"to":5},"critical":{"from":"No","to":"Yes"}}}],
    "E.spares.removed":[{"partCode":"SP-OLD-009"}]

    /* Similar entries for F, G, H as needed */
  }
}
```

---

## 7) Performance & code notes

* Debounce change detection (e.g., 150ms) to avoid re-render churn.
* Use a stable `fieldPath` map to generate diff keys (e.g., `"A.maker"`, `"C.workOrders[0].frequencyValue"`).
* Preserve the existing component tree and search on the left. No changes there.

---

## 8) Acceptance criteria (must pass)

1. Opening a Component CR shows **all sections A–H pre-filled** with the component’s current data (exactly matching the read-only page).
2. Any changed field immediately turns **red** and increments the **section change count** chip.
3. **Work Orders**: I can **edit**, **add**, and **delete** rows; edits are highlighted; deletes are strike-through; new rows are captured. Submit builds the 3 CR arrays (added/modified/removed) correctly.
4. **Spares**: I can **edit** Min/Critical/Location, **link** new spare(s), and **unlink** existing ones; submit builds the 3 CR arrays correctly.
5. **No live data** (components/WOs/spares) is altered by this screen.
6. Submit posts the CR payload with `summary` and `diff` as above and returns to list with success toast.
7. Cancel leaves no side effects.

---

## 9) Out of scope (for this task)

* Approval UI and merge actions (that will apply the diff to live data).
* CR flows for Work Orders category, Spares category, Stores category (to be done later similarly).
* Running Hours logic.

---

### API (if needed)

If an endpoint doesn’t exist yet, create:

* `POST /api/modify-pms/requests`
  Body = payload above. Returns `{ requestId, status:"Pending Approval" }`.

---

### QA scenarios

* Change a few single-value fields in A; verify highlighting and chip counts.
* Edit one existing WO and delete another; add a new WO; submit; verify payload arrays and from/to values.
* Edit spare Min & Critical; link a new spare; unlink a spare; submit; verify arrays.
* Revert a field back to original; red highlight disappears and counts decrement.
* Submit with a missing required field in a new WO → inline error, no POST.

---

**Please implement exactly as above, keeping the rest of the app untouched.**
