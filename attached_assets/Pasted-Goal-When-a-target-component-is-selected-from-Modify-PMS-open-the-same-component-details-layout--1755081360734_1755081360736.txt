Goal:
When a target component is selected from Modify PMS, open the same component details layout (Sections A → H) in an editable state pre-filled with the component’s current data. Any edits must be highlighted and captured as a change request draft, not written to live data.
Scope (only this)

    Change Request flow for Components only (others unchanged in this patch).

    Pages involved:

        ModifyPMSChangeRequest modal (the “New Change Request” dialog)

        ComponentsSelectTarget (the “Select Target” overlay/screen)

        ComponentRegisterEdit (the blue editable form that’s currently blank)

        ComponentDetails (the read view used on the Components page)

    Do not modify the general Components page behavior, Add/Edit component behavior, tree numbering, WO screens, spares/stores modules, or any menus/filters.

What’s broken now

    In Modify PMS → Select Target → Use This Target, ComponentRegisterEdit opens with the right layout (blue inputs) but all fields are empty (no prefill), even though the read-only page shows the data correctly.

Required behavior

    Pass the selected target identity

        From ModifyPMSChangeRequest after “Select Target → Use This Target”, store the target as:

    {
      type: 'COMPONENT',
      componentId: string,       // internal ID if we have it
      componentCode: string,     // e.g., "1.1.1" (fallback key)
      vesselId: string
    }

    Navigate to the edit form with an explicit CR mode context:

        Route example: /components/edit?mode=cr&componentId=...
        (If only componentCode is available, pass componentCode=... too.)

Prefill the edit form with current data

    In ComponentRegisterEdit, detect mode=cr and incoming componentId|componentCode.

    Fetch the current record using existing API (do not create new endpoints):

        Try GET /api/components/:id

        Fallback: GET /api/components/by-code/:componentCode?vesselId=...

    Bind the response to the form’s controlled inputs so every field in Sections A–H shows the live values:

        Section A (Component Information): maker, model, serialNo, drawingNo, componentCode (readonly), componentCategory, location, critical, conditionBased, installationDate, commissionedDate, rating, unitsCount, department, parentComponent, dimensions, notes

        Section B (Running hours & CM): runningHours.current, runningHours.updatedAt, metrics[]

        Section C (Work Orders): render table with existing linked WOs (titles/frequencies). Read-only list here in this patch; editing WOs from CR will be a later patch.

        Section D (Maintenance History): render existing rows (read-only in this patch).

        Section E (Spares): show linked spares rows (read-only in this patch).

        Sections F, G, H: render existing attachments/regs/requisitions (read-only in this patch).

    Ensure vessel selector, search, criticality filter in the header remain functional but do not alter the bound record in CR mode.

Change tracking & highlighting

    On first data load, keep a deep clone originalData.

    For each input, on change, compare with originalData:

        If different, add class .cr-changed to that control and .cr-changed-row to its row.

        Style: subtle red outline or left border (no layout changes).

    Provide a “Changes” chip per section header showing the count of changed fields in that section (e.g., A. Component Information (3 changes)).

Draft change request payload (do not update live data)

    The Submit button (bottom right of the blue form) in CR mode must:

        Not call the standard “save component” endpoint.

        Instead, assemble a diff-only payload:

        {
          "type": "COMPONENT",
          "target": { "componentId": "...", "componentCode": "...", "vesselId": "..." },
          "original": { "fieldPath": "originalValue", ... },   // only for changed fields
          "proposed": { "fieldPath": "newValue", ... },
          "sectionSummary": { "A": 3, "B": 1 },
          "title": "<value from CR modal>",
          "reason": "<value from CR modal>",
          "attachments": []   // keep for future
        }

        POST to existing CR endpoint (or create if missing): POST /api/modify-pms/requests

        On success, return to the Change Requests list and show the new item with Pending Approval status.

    Keep the standard “Save” behavior untouched when not in mode=cr.

Header + breadcrumbs for CR mode

    In ComponentRegisterEdit while mode=cr:

        Replace the default title with Change Request Draft – <Component Name>.

        Show a small sticky bar with: Target: <componentCode> • Vessel: <name> • Status: Draft.

        Buttons: Cancel (back to CR list) and Submit for Approval (posts draft as above).

        Hide “Add Sub Component” in CR mode only.

Edge cases

    If the component cannot be fetched:

        Show inline error: “Could not load the component details for change request.” and provide Back.

    If some fields are null/undefined, prefill with empty values but still bind (no placeholders that look like content).

    Read-only computed or code fields (componentCode) must remain read-only in CR mode.

Styling

    Keep existing blue editable form.

    Add small CSS only:

        .cr-changed { outline: 2px solid #e06666 !important; }
        .cr-changed-row { box-shadow: inset 3px 0 0 #e06666; }
        .cr-sticky { position: sticky; top: 0; z-index: 2; background: #fff; border-bottom: 1px solid #eee; }

        Do not alter layout, paddings, or typography.

Acceptance criteria

Selecting a component via Modify PMS → Select Target → Use This Target opens the same component page layout in blue edit mode pre-filled with the existing data for Sections A–H.

Editing any field immediately highlights that input in red and increments the section’s change counter.

Clicking Submit for Approval creates a change request (diff-only), returns to the CR list, and shows it as Pending Approval.

Live component data remains unchanged until office approval workflow (future phase).

    Normal Add/Edit Component flow (outside mode=cr) behaves exactly as before.

Minimal code hooks (names illustrative)

    ModifyPMSChangeRequest.tsx

        Save selected target into CR draft store.

        Route to /components/edit?mode=cr&componentId=...&componentCode=...&vesselId=....

    ComponentRegisterEdit.tsx

        Read query params; if mode==='cr' → CR mode.

        useEffect fetch current record based on componentId|componentCode + vesselId.

        Bind data to form state; maintain originalData.

        Diff on change; set .cr-changed.

        On submit → build diff payload & POST /api/modify-pms/requests.

    api/modifyPms.ts

        createChangeRequest(payload) → POST.

        Re-use existing CR model if present; if not, create a minimal one with type, target, original, proposed, title, reason, status.

Test script (manual)

    Open Components page to the Hydrohpore Unit and visually note values.

    Go to Modify PMS → New Change Request → Category: Components → Select Target.

    Pick the same component (1.1.1 Hydrophore Unit) → Use This Target.

    Verify the blue form is pre-filled with all values identical to read view.

    Change Maker and Location → they turn red and section shows “(2 changes)”.

    Click Submit for Approval → arrive at Change Requests list with the new item Pending Approval.

    Refresh Components page: live data unchanged (edits only in CR).

Important “do not touch”

    Do not change: component tree numbering, work order numbering/naming, spares/stores modules, running hours list, export buttons, or any unrelated filters/UI.

    No schema changes to live component collection.