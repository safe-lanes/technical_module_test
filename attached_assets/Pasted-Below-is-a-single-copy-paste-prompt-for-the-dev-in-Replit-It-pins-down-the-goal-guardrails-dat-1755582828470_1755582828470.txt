Below is a single, copy-paste prompt for the dev in Replit. It **pins down the goal, guardrails, data model, API, and UI behavior** so the “Forms” in **Admin → Forms** are an **exact 1:1 mirror** of the forms already used elsewhere in the app (Components, Work Orders – Planned, Work Orders – Unplanned). Please follow it literally.

---

# PROMPT: Admin → Forms (Exact Form Mirroring with Version Control)

## Goal (read first)

Implement **Admin → Forms** as a **configuration & versioning layer** that mirrors—**exactly**—the live forms already used in the product. When a form changes here, a **new version** is created and **only that new version** replaces the live form after Save/Publish.
**Do not invent fields, labels, or layout. Pull them from the existing live forms and preserve them 1:1.**

Forms to mirror now:

1. **Add Component Form** (Sections A–H exactly as in Components module)
2. **Work Order Form (Planned)** – the same form used to create a planned WO (Part A + Part B as in the app)
3. **Work Order Form (Unplanned)** – the same form used to create a breakdown/unplanned WO (Part A + Part B as in the app)

> If anything is ambiguous, STOP and ask for the exact field/section from the live screen before proceeding.

---

## Non-negotiable guardrails

* **Exactness**: Labels, order, required flags, placeholder text, control types (text, select, date, toggle, multi-select), and section grouping must **match the live forms pixel-for-pixel where feasible**.
* **Read model first**: Bootstrap each Admin form’s current **schema** by **reading the live form schema** from the operational modules (do not hardcode your own). Create version **01** from that live schema.
* **No runtime breakage**: Publishing a new version must **not** break existing records. Operational screens always render the **latest published version**; existing saved records keep their data.
* **History kept**: Older versions are kept read-only and can be viewed or rolled back.

---

## Data model (SQL or equivalent)

**tables**

* `form_definitions`

  * `id` (pk)
  * `name` (enum: ADD\_COMPONENT, WO\_PLANNED, WO\_UNPLANNED)
  * `subgroup` (nullable text, e.g., “New Work Order (Planned)”)
* `form_versions`

  * `id` (pk)
  * `form_id` (fk → form\_definitions.id)
  * `version_no` (int, starts at 1, increments)
  * `version_date` (datetime)
  * `status` (enum: DRAFT, PUBLISHED, ARCHIVED)
  * `author_user_id`
  * `changelog` (text)
  * `schema_json` (JSON)  ← the **exact** field/section layout + metadata, see schema shape below
* `form_version_usage` (optional audit)

  * `id` (pk)
  * `form_version_id` (fk)
  * `used_in_module` (text)
  * `used_at` (datetime)

**`schema_json` shape (example)**

```json
{
  "title": "Add Component Form",
  "sections": [
    {
      "key": "A",
      "title": "A. Component Information",
      "layout": "grid-4", 
      "fields": [
        {"key":"maker","label":"Maker","type":"text","required":true,"placeholder":"","options":null},
        {"key":"model","label":"Model","type":"text","required":false},
        {"key":"serialNo","label":"Serial No","type":"text","required":false},
        {"key":"drawingNo","label":"Drawing No","type":"text","required":false},
        ...
      ]
    },
    {
      "key":"B",
      "title":"B. Running Hours & Condition Monitoring Metrics",
      "layout":"grid-2",
      "fields":[
        {"key":"runningHours","label":"Running Hours","type":"number"},
        {"key":"dateUpdated","label":"Date Updated","type":"date"},
        {"key":"metrics","label":"Condition Monitoring Metrics","type":"repeater","columns":[
          {"key":"metric","label":"Metric","type":"text"},
          {"key":"threshold","label":"Alerts/Thresholds","type":"text"}
        ]}
      ]
    },
    ...
  ]
}
```

> The fields/sections and their order **must be serialized from the live forms**. Use real keys currently powering those forms so operational screens can render them unchanged.

---

## Back-end endpoints

* `GET /admin/forms` → list forms with latest version\_no, version\_date, status.
* `GET /admin/forms/:formId/versions` → list all versions (latest first).
* `GET /admin/forms/:formId/versions/:versionId` → get schema\_json (read-only if not Draft).
* `POST /admin/forms/:formId/versions` → create **new draft** by cloning the current **published** version’s schema\_json (or from v1 on first run).
* `PUT /admin/forms/:formId/versions/:versionId/schema` → update draft schema\_json (only when status=DRAFT).
* `POST /admin/forms/:formId/versions/:versionId/publish` → set status=PUBLISHED, increment version\_no, set version\_date, demote previous published to ARCHIVED, write changelog.
* `POST /admin/forms/:formId/versions/:versionId/discard` → delete Draft.
* `POST /admin/forms/:formId/versions/:versionId/rollback` → copy that version as a new Draft, then publish.

**Operational read**

* `GET /forms/runtime/:name` → returns **latest PUBLISHED** `schema_json` for rendering in Components/Work Orders modules.

  * name ∈ {ADD\_COMPONENT, WO\_PLANNED, WO\_UNPLANNED}

---

## UI behavior

### A) Forms list (matches screenshot)

Columns: Form Name, Form Sub Group, Version No, Version Date, Actions (✎).
Search by name/subgroup.

### B) Editor (Configuration Mode)

* Load the selected version’s schema\_json into a **drag-safe editor**, but:

  * **By default**, create a **new Draft** by cloning latest **PUBLISHED**.
  * Top bar: **Version No (auto)**, **Version Date**, **Status** (Draft/Published), buttons: **Save Draft**, **Discard Ver**, **Exit Config**, **Publish** (enabled only if valid).
* **Exact mirroring**: render the sections and fields exactly as currently used live.
* **Safeguards**:

  * If an admin tries to add a field with a key not in live data contracts, show a warning and require confirmation with a note in changelog.
  * Moving/removing fields shows a “Breaking change?” tooltip—force changelog note.
* **Diff view** (toggle): highlight changes vs current published (added: green; removed: strike-through red; modified: amber).

### C) Version history drawer

* Show list of versions (no, date, author, status, changelog).
* Actions: **View**, **Rollback** (creates new Draft from that version).

---

## Bootstrap: read live schemas (critical)

On first load, populate `form_definitions` + `form_versions` by **querying the live form renderers** used in:

* Components → “Add / Edit Component” (Sections A–H)
* Work Orders → New Work Order (Planned) (Part A + Part B)
* Work Orders → Unplanned Work Order (Part A + Part B)

Serialize the currently rendered structure to `schema_json` and mark as **version\_no = 1, status = PUBLISHED**.
**Do not** type new labels or reorder anything.

---

## Runtime contract with operational modules

* Operational modules must **only** call `GET /forms/runtime/:name` to render the **latest published** schema.
* Field & section rendering must obey the types/required flags from `schema_json`.
* Existing records continue to store values by field key; when a newer version hides/removes a field, operational view should gracefully ignore missing values.

---

## Acceptance checklist

* [ ] Forms list shows 3 forms with correct latest version & dates.
* [ ] Opening any form loads a **Draft** cloned from latest Published.
* [ ] The initial Published v1 for each form exactly matches the live screen **today** (labels, order, required flags, control types, sections A–H / Part A–B).
* [ ] Publishing increments version number and updates version date; history retains older versions.
* [ ] Operational modules render with the latest Published schema and remain fully functional.
* [ ] Diff view clearly highlights changed/added/removed fields.
* [ ] Rollback works (creates Draft from prior version, then can publish).
* [ ] No layout/label/type drift from the live forms unless explicitly edited and documented in the changelog.
* [ ] If any detail is unclear, **ask for the live screen reference and do not guess.**

---

## Notes for developer

* Keep UI styling consistent with the app (blue highlights `#52BAF3` for config inputs).
* This feature is **form versioning only**; it does **not** alter business rules (e.g., WO approval logic).
* Add robust validation before publish: unique field keys in a section, required labels present, etc.
* Log all admin actions to audit.

---

**Remember:** The forms here must be **exactly the same** as those used in the software. If you cannot read the live schema for any section/field, halt and request the exact spec or a screenshot reference before proceeding.
