Great — here’s **Prompt B (Phase 1.2)**. It adds **structured “Propose Changes” forms** + a **Review Diff** step. It still **does not apply anything** to PMS; we only capture the proposal cleanly.

---

**Do not change anything except what is written below. If anything is unclear, ask first.**

# Modify PMS — Change Requests (Phase 1.2)

## Goal (very important)

* After a request has a **target** (from Phase 1.1), allow the user to **propose specific field changes** via controlled forms.
* Store the proposal as a **clean diff** (`proposedChangesJson`) and optional **move preview** (for components).
* **Do NOT** modify any PMS entity. No apply/renumber, no recalculation of due dates beyond read-only preview strings.

---

## A) Data additions (minimal)

Extend `change_request` with two nullable fields:

* `proposedChangesJson` (JSON)

  * Array of change objects:

    ```
    [
      {
        "path": "workOrder.frequency.type",   // dot-path per entity schema
        "label": "Frequency Type",            // human label for diff table
        "before": "Period",
        "after": "Period"
      },
      ...
    ]
    ```
* `movePreviewJson` (JSON, components only, nullable)

  ```
  {
    "oldPath": "6.1.1 Main Engine > 6.1.1.2 Cylinder Liners",
    "newPath": "6.2 Diesel Generators > 6.2.1 DG #1 > 6.2.1.4 Cylinder Liners",
    "oldCode": "6.1.1.2",
    "newCodePreview": "6.2.1.4"   // preview only, not persisted to components
  }
  ```

> Do not alter other fields. Keep `snapshotBeforeJson` from Phase 1.1.

---

## B) UI — Propose Changes section (only when target is set)

On the New/Edit Change Request screen (status = `draft` or `returned`), show a **“Propose Changes”** accordion/card **below** the Target summary.

**Pattern (shared across entity types)**

* Each editable field row shows:

  * **Label**, current value (from `snapshotBeforeJson.fields`)
  * Toggle **“Propose”** → when ON, enable input.
  * Input component (dropdown/text/date/etc.)
* Only fields with “Propose” toggled **ON** are collected into the diff.
* Bottom buttons: **Review Changes** (primary), **Clear Proposed** (secondary).

### Entity-specific fields (initial scope)

#### 1) Work Order (when `targetType='work_order'`)

* **Job Title** (text, 120 chars)
* **Frequency Type** (dropdown: `Period`, `Running Hours`)
* **Frequency Value & Unit**

  * If `Period` → **every \[N]** + **unit** (`Days`, `Weeks`, `Months`)
  * If `Running Hours` → **every \[N] hours**
* **Criticality** (Yes/No)
* **Assigned Rank** (dropdown: same options used in WO module)
* **Instructions** (multiline text) — store as text only; don’t touch attachments yet

*Input validation*

* Period: N ≥ 1
* Running Hours: N ≥ 1
* Strings trimmed; keep max lengths same as WO module.

#### 2) Component (when `targetType='component'`)

* **Section A — Component Information** (show these as separate rows):

  * Maker, Model, Serial No, Department, **Component Category** (not “Equipment Category”), Location,
  * Commissioned Date (date), **Critical** (Yes/No), **Class Item** (Yes/No)
* **Move Component (Preview)**:

  * Button **“Propose New Parent”** → opens the **Component tree** (same overlay as Phase 1.1).
  * User picks the new parent node (read-only preview on right).
  * On confirm, fill **movePreview** with `oldPath`, `newPath`, and compute a **new code preview** using **the same single-digit coding scheme** already used for the tree (pure preview; no persistence).
  * Allow **Remove move** to clear the preview.

#### 3) Spare (when `targetType='spare'`)

* **UOM** (dropdown per your UOM list)
* **Min** (integer ≥ 0; blank allowed → treated as N/A)
* **Critical** (Yes/No)
* **Location** (text)

#### 4) Store (when `targetType='store'`)

* **Item Name** (text)
* **UOM** (dropdown)
* **Min** (integer ≥ 0; blank allowed)
* **Location** (text)

---

## C) Review Diff step (modal)

* Clicking **Review Changes** builds a **diff array** from only the toggled fields and shows a modal:

  * Table columns: **Field**, **Current**, **Proposed**.
  * If **Move (preview)** exists: show a separate card with **oldPath / newPath** and **oldCode / newCodePreview**.
* Require **Reason/Business Justification** (already on form). If empty, block submit.
* Buttons: **Save as Draft**, **Submit Request**.

  * **Save as Draft** → stores `proposedChangesJson` (+ `movePreviewJson` if any) but keeps status `draft`.
  * **Submit** → status `submitted`; sets `submittedAt`.

> When saving, overwrite previous `proposedChangesJson` with the latest; if the user cleared all toggles, store `[]` (and block submit with message “Please propose at least one change or add a reason-only request.” — your choice; I suggest requiring ≥1 proposed field for clarity).

---

## D) Detail View (office + vessel)

Add two new tabs/cards:

1. **Proposed Changes**

   * Show the diff table (Field / Before / Proposed).
   * If present, show **Move (Preview)** card with paths and codes.
2. **Snapshot** (reuse from Phase 1.1)

   * Show read-only snapshot table.

**Office-only actions** (unchanged from Phase 1.0):

* Approve / Reject / Return (require comment).
* These actions **do not** apply anything to PMS in this phase.

---

## E) Small, read-only “impact preview” (optional but safe)

* For **WO frequency** changes: show a non-binding text under the diff:
  “If approved, next due date will be recalculated per new frequency.” (No calculation needed yet.)
* For **Spare/Store Min** changes: show “Stock badge would become OK/Low/N/A based on current ROB.” (You can compute this visually from snapshot ROB and proposed Min; still read-only.)

Do **not** persist or touch any PMS data.

---

## F) API endpoints

* `PUT /modify-pms/requests/:id/proposed`
  Body: `{ proposedChangesJson: Change[], movePreviewJson?: MovePreview | null }`

  * Only allowed when status is `draft` or `returned`.
* The existing `PUT /modify-pms/requests/:id` (edit) should accept reason/title updates.
* `PUT /modify-pms/requests/:id/submit` keeps behavior from Phase 1.0 (now also requires that a target is set and `proposedChangesJson` is non-empty).

**Types**

```
type Change = {
  path: string;    // e.g., "component.sectionA.maker"
  label: string;   // "Maker"
  before: any;
  after: any;
};

type MovePreview = {
  oldPath: string;
  newPath: string;
  oldCode: string;
  newCodePreview: string;
};
```

---

## G) Guard rails (non-goals)

* Do **not** write to Components / WOs / Spares / Stores.
* Do **not** alter tree codes, WO next-dues, or stock values.
* Do **not** add attachments handling beyond what already exists.
* Preserve all existing module screens.

---

## H) Acceptance checks

1. With a selected target, the **Propose Changes** section renders the right fields **read-only until “Propose” is toggled**.
2. **Review Changes** shows only the fields the user opted to change, with correct current/proposed values.
3. Component **Move (Preview)** lets the user pick a new parent; **newCodePreview** is displayed; no data is applied to PMS.
4. **Save as Draft** persists `proposedChangesJson` (and `movePreviewJson` when set). Reopening the draft reloads toggles/values.
5. **Submit** is blocked unless: Title, Category, Reason, Target, and ≥1 proposed change present.
6. Office **Detail View** shows the Snapshot and Proposed Changes tabs/cards. Approve/Reject/Return work exactly as Phase 1.0 and **do not** modify PMS entities.

---

When this is working cleanly, we can do **Phase 2**: controlled **Apply** + **Rollback**, with very tight scope (one entity type at a time).
